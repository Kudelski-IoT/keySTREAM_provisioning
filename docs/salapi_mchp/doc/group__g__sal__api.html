<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SAL API: SAL Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="kudelski.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LOGO_IOT_IOTHINGS.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SAL API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__g__sal__api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SAL Interface</div>  </div>
</div><!--header-->
<div class="contents">

<p>Common sal constants.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_k_sal_obj_association_info.html">TKSalObjAssociationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holds the associated Objects.  <a href="struct_t_k_sal_obj_association_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga60436668f147031daa96e2c176de7a79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga60436668f147031daa96e2c176de7a79">C_K_KTA__CHIP_SK_ID</a>&#160;&#160;&#160;(0x0001u)</td></tr>
<tr class="memdesc:ga60436668f147031daa96e2c176de7a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crypto Object Ids.  <a href="group__g__sal__api.html#ga60436668f147031daa96e2c176de7a79">More...</a><br /></td></tr>
<tr class="separator:ga60436668f147031daa96e2c176de7a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad547f4070fe49f333e1851c3c14c5ffc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gad547f4070fe49f333e1851c3c14c5ffc">C_K_KTA__L1_FIELD_KEY_ID</a>&#160;&#160;&#160;(0x0002u)</td></tr>
<tr class="memdesc:gad547f4070fe49f333e1851c3c14c5ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1 Filed Key Id(Persistent).  <a href="group__g__sal__api.html#gad547f4070fe49f333e1851c3c14c5ffc">More...</a><br /></td></tr>
<tr class="separator:gad547f4070fe49f333e1851c3c14c5ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99101c814ce43bf17a954d6fa00c282c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga99101c814ce43bf17a954d6fa00c282c">C_K_KTA__VOLATILE_ID</a>&#160;&#160;&#160;(0x8000u)</td></tr>
<tr class="memdesc:ga99101c814ce43bf17a954d6fa00c282c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile Id.  <a href="group__g__sal__api.html#ga99101c814ce43bf17a954d6fa00c282c">More...</a><br /></td></tr>
<tr class="separator:ga99101c814ce43bf17a954d6fa00c282c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8454af66db0bf3bf9e2b9e83bb46cb32"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga8454af66db0bf3bf9e2b9e83bb46cb32">C_K_KTA__VOLATILE_2_ID</a>&#160;&#160;&#160;(0x8001u)</td></tr>
<tr class="memdesc:ga8454af66db0bf3bf9e2b9e83bb46cb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile 2 Id.  <a href="group__g__sal__api.html#ga8454af66db0bf3bf9e2b9e83bb46cb32">More...</a><br /></td></tr>
<tr class="separator:ga8454af66db0bf3bf9e2b9e83bb46cb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13d0adcc686dc3c5a9e4f7a5f1e270f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga13d0adcc686dc3c5a9e4f7a5f1e270f1">C_K_KTA__VOLATILE_3_ID</a>&#160;&#160;&#160;(0x8002u)</td></tr>
<tr class="memdesc:ga13d0adcc686dc3c5a9e4f7a5f1e270f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volatile 3 Id.  <a href="group__g__sal__api.html#ga13d0adcc686dc3c5a9e4f7a5f1e270f1">More...</a><br /></td></tr>
<tr class="separator:ga13d0adcc686dc3c5a9e4f7a5f1e270f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a74cb2e285608eaf622242192082ed8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga1a74cb2e285608eaf622242192082ed8">C_K_KTA__LIFE_CYCLE_STATE_STORAGE_ID</a>&#160;&#160;&#160;(0x4000u)</td></tr>
<tr class="memdesc:ga1a74cb2e285608eaf622242192082ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent Storage_Ids.  <a href="group__g__sal__api.html#ga1a74cb2e285608eaf622242192082ed8">More...</a><br /></td></tr>
<tr class="separator:ga1a74cb2e285608eaf622242192082ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb553e6d709a49b8eda083e7ed659431"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gafb553e6d709a49b8eda083e7ed659431">C_K_KTA__ROT_PUBLIC_UID_STORAGE_ID</a>&#160;&#160;&#160;(0x4001u)</td></tr>
<tr class="memdesc:gafb553e6d709a49b8eda083e7ed659431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rot public UID ID.  <a href="group__g__sal__api.html#gafb553e6d709a49b8eda083e7ed659431">More...</a><br /></td></tr>
<tr class="separator:gafb553e6d709a49b8eda083e7ed659431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf931f821fe338a445b20ce5170da082"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gabf931f821fe338a445b20ce5170da082">C_K_KTA__SEALED_DATA_STORAGE_ID</a>&#160;&#160;&#160;(0x4002u)</td></tr>
<tr class="memdesc:gabf931f821fe338a445b20ce5170da082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sealed data ID.  <a href="group__g__sal__api.html#gabf931f821fe338a445b20ce5170da082">More...</a><br /></td></tr>
<tr class="separator:gabf931f821fe338a445b20ce5170da082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3190136a0f640265c246a8bc738ac9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga4a3190136a0f640265c246a8bc738ac9">C_K_KTA__L1_KEY_MATERIAL_DATA_ID</a>&#160;&#160;&#160;(0x4003u)</td></tr>
<tr class="memdesc:ga4a3190136a0f640265c246a8bc738ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1 key material data ID.  <a href="group__g__sal__api.html#ga4a3190136a0f640265c246a8bc738ac9">More...</a><br /></td></tr>
<tr class="separator:ga4a3190136a0f640265c246a8bc738ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2496245ea4b9d9523dab012ac169ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga2b2496245ea4b9d9523dab012ac169ce">C_K_KTA__DEVICE_CERTIFICATE_ID</a>&#160;&#160;&#160;(0x4004u)</td></tr>
<tr class="memdesc:ga2b2496245ea4b9d9523dab012ac169ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device certificate ID.  <a href="group__g__sal__api.html#ga2b2496245ea4b9d9523dab012ac169ce">More...</a><br /></td></tr>
<tr class="separator:ga2b2496245ea4b9d9523dab012ac169ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9377b77a84ffea3d7fc317944ebde394"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga9377b77a84ffea3d7fc317944ebde394">C_K_KTA__SIGNER_CERTIFICATE_ID</a>&#160;&#160;&#160;(0x4005u)</td></tr>
<tr class="memdesc:ga9377b77a84ffea3d7fc317944ebde394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signer certificate ID.  <a href="group__g__sal__api.html#ga9377b77a84ffea3d7fc317944ebde394">More...</a><br /></td></tr>
<tr class="separator:ga9377b77a84ffea3d7fc317944ebde394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a130e78400cf1c3f6f2ed7309281372"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga7a130e78400cf1c3f6f2ed7309281372">C_K_KTA__SIGNER_PUB_KEY_ID</a>&#160;&#160;&#160;(0x4006u)</td></tr>
<tr class="memdesc:ga7a130e78400cf1c3f6f2ed7309281372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signer public key.  <a href="group__g__sal__api.html#ga7a130e78400cf1c3f6f2ed7309281372">More...</a><br /></td></tr>
<tr class="separator:ga7a130e78400cf1c3f6f2ed7309281372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbcb95dc7498df4d274bbf2eae65cdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga9cbcb95dc7498df4d274bbf2eae65cdf">C_K_KTA__HKDF_ACT_MODE</a>&#160;&#160;&#160;(0x0000u)</td></tr>
<tr class="memdesc:ga9cbcb95dc7498df4d274bbf2eae65cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">HKDF Extract Mode.  <a href="group__g__sal__api.html#ga9cbcb95dc7498df4d274bbf2eae65cdf">More...</a><br /></td></tr>
<tr class="separator:ga9cbcb95dc7498df4d274bbf2eae65cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3281679cde4780613e81d006c1d0392"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gad3281679cde4780613e81d006c1d0392">C_K_KTA__HKDF_GEN_MODE</a>&#160;&#160;&#160;(0x0001u)</td></tr>
<tr class="memdesc:gad3281679cde4780613e81d006c1d0392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Mode.  <a href="group__g__sal__api.html#gad3281679cde4780613e81d006c1d0392">More...</a><br /></td></tr>
<tr class="separator:gad3281679cde4780613e81d006c1d0392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba95d7c9b0d8ea6447cb91ac85cd4d25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gaba95d7c9b0d8ea6447cb91ac85cd4d25">C_K_KTA__CHIPSET_UID_MAX_SIZE</a>&#160;&#160;&#160;(32u)</td></tr>
<tr class="memdesc:gaba95d7c9b0d8ea6447cb91ac85cd4d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of chipset id field, in bytes.  <a href="group__g__sal__api.html#gaba95d7c9b0d8ea6447cb91ac85cd4d25">More...</a><br /></td></tr>
<tr class="separator:gaba95d7c9b0d8ea6447cb91ac85cd4d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a9ad49d0d8007b1e0d0b7d239e1d8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga08a9ad49d0d8007b1e0d0b7d239e1d8e">C_K_KTA__CHIP_CERT_MAX_SIZE</a>&#160;&#160;&#160;<a class="el" href="crypto_config_8h.html#aff00b687c80be7953eb95b41f90625ac">C_K__CHIP_CERT_MAX_SIZE_VENDOR_SPECIFIC</a></td></tr>
<tr class="memdesc:ga08a9ad49d0d8007b1e0d0b7d239e1d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of chipset cert field, in bytes.  <a href="group__g__sal__api.html#ga08a9ad49d0d8007b1e0d0b7d239e1d8e">More...</a><br /></td></tr>
<tr class="separator:ga08a9ad49d0d8007b1e0d0b7d239e1d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c42ef9955fd67e4e6f0bde190a518f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga0c42ef9955fd67e4e6f0bde190a518f6">C_K_KTA__RANDOM_MAX_SIZE</a>&#160;&#160;&#160;(256u)</td></tr>
<tr class="memdesc:ga0c42ef9955fd67e4e6f0bde190a518f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of random field, in bytes.  <a href="group__g__sal__api.html#ga0c42ef9955fd67e4e6f0bde190a518f6">More...</a><br /></td></tr>
<tr class="separator:ga0c42ef9955fd67e4e6f0bde190a518f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e27a13cddbad36162b503656d2393c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga34e27a13cddbad36162b503656d2393c">C_K_KTA__SHARED_SECRET_KEY_MAX_SIZE</a>&#160;&#160;&#160;(32u)</td></tr>
<tr class="memdesc:ga34e27a13cddbad36162b503656d2393c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of secret key field, in bytes.  <a href="group__g__sal__api.html#ga34e27a13cddbad36162b503656d2393c">More...</a><br /></td></tr>
<tr class="separator:ga34e27a13cddbad36162b503656d2393c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65fae2d607180c797d8bf2e9abae6d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gad65fae2d607180c797d8bf2e9abae6d7">C_K_KTA__PUBLIC_KEY_MAX_SIZE</a>&#160;&#160;&#160;(64u)</td></tr>
<tr class="memdesc:gad65fae2d607180c797d8bf2e9abae6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of Public key field, in bytes.  <a href="group__g__sal__api.html#gad65fae2d607180c797d8bf2e9abae6d7">More...</a><br /></td></tr>
<tr class="separator:gad65fae2d607180c797d8bf2e9abae6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d59819f7f89db2af376cf6934b82e99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga6d59819f7f89db2af376cf6934b82e99">C_K_KTA__HMAC_MAX_SIZE</a>&#160;&#160;&#160;(16u)</td></tr>
<tr class="memdesc:ga6d59819f7f89db2af376cf6934b82e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of Mac key field, in bytes.  <a href="group__g__sal__api.html#ga6d59819f7f89db2af376cf6934b82e99">More...</a><br /></td></tr>
<tr class="separator:ga6d59819f7f89db2af376cf6934b82e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad913c59c4cf8625f858e15b7bd4e21a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gad913c59c4cf8625f858e15b7bd4e21a7">C_K_KTA__HKDF_ACT_SALT_MAX_SIZE</a>&#160;&#160;&#160;(64u)</td></tr>
<tr class="memdesc:gad913c59c4cf8625f858e15b7bd4e21a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of salt for activation mode key field, in bytes.  <a href="group__g__sal__api.html#gad913c59c4cf8625f858e15b7bd4e21a7">More...</a><br /></td></tr>
<tr class="separator:gad913c59c4cf8625f858e15b7bd4e21a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga742053958c22ff18609373a8e854077b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga742053958c22ff18609373a8e854077b">C_K_KTA__HKDF_GEN_SALT_MAX_SIZE</a>&#160;&#160;&#160;(16u)</td></tr>
<tr class="memdesc:ga742053958c22ff18609373a8e854077b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of salt for generic mode key field, in bytes.  <a href="group__g__sal__api.html#ga742053958c22ff18609373a8e854077b">More...</a><br /></td></tr>
<tr class="separator:ga742053958c22ff18609373a8e854077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4f0c70eff92029a980bdaf30ca88fa2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gac4f0c70eff92029a980bdaf30ca88fa2">C_K_KTA__ROT_PUBLIC_UID_MAX_SIZE</a>&#160;&#160;&#160;(8u)</td></tr>
<tr class="memdesc:gac4f0c70eff92029a980bdaf30ca88fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of Rot public uid field, in bytes.  <a href="group__g__sal__api.html#gac4f0c70eff92029a980bdaf30ca88fa2">More...</a><br /></td></tr>
<tr class="separator:gac4f0c70eff92029a980bdaf30ca88fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bee391727a7cdab89de2b46865b1c00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga5bee391727a7cdab89de2b46865b1c00">C_K_KTA__CMD_FIELD_MAX_SIZE</a>&#160;&#160;&#160;(1024u)</td></tr>
<tr class="memdesc:ga5bee391727a7cdab89de2b46865b1c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of command field , in bytes.  <a href="group__g__sal__api.html#ga5bee391727a7cdab89de2b46865b1c00">More...</a><br /></td></tr>
<tr class="separator:ga5bee391727a7cdab89de2b46865b1c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc11d93065143b24a20b58e1dc16aaec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gafc11d93065143b24a20b58e1dc16aaec">C_K_KTA__SEALED_INFORMATION_MAX_SIZE</a>&#160;&#160;&#160;(133u)</td></tr>
<tr class="memdesc:gafc11d93065143b24a20b58e1dc16aaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximal size of sealed information, in bytes.  <a href="group__g__sal__api.html#gafc11d93065143b24a20b58e1dc16aaec">More...</a><br /></td></tr>
<tr class="separator:gafc11d93065143b24a20b58e1dc16aaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8e84430e52400313049a4910d394ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a></td></tr>
<tr class="memdesc:ga1a8e84430e52400313049a4910d394ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">K Sal Api.  <a href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">More...</a><br /></td></tr>
<tr class="separator:ga1a8e84430e52400313049a4910d394ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e0c167e5ca0fef754a8b26051cb9ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga66e0c167e5ca0fef754a8b26051cb9ed">C_SAL_OBJECT__TYPE_DATA</a>&#160;&#160;&#160;(0u)</td></tr>
<tr class="memdesc:ga66e0c167e5ca0fef754a8b26051cb9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sal object type data.  <a href="group__g__sal__api.html#ga66e0c167e5ca0fef754a8b26051cb9ed">More...</a><br /></td></tr>
<tr class="separator:ga66e0c167e5ca0fef754a8b26051cb9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74d4d186f6d96c61dcb56a6c9f8ab47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gad74d4d186f6d96c61dcb56a6c9f8ab47">C_SAL_OBJECT__TYPE_KEY</a>&#160;&#160;&#160;(1u)</td></tr>
<tr class="memdesc:gad74d4d186f6d96c61dcb56a6c9f8ab47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sal object type key.  <a href="group__g__sal__api.html#gad74d4d186f6d96c61dcb56a6c9f8ab47">More...</a><br /></td></tr>
<tr class="separator:gad74d4d186f6d96c61dcb56a6c9f8ab47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1984b867e1d3d9915db638356659c9bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga1984b867e1d3d9915db638356659c9bb">C_SAL_OBJECT__TYPE_CERTIFICATE</a>&#160;&#160;&#160;(2u)</td></tr>
<tr class="memdesc:ga1984b867e1d3d9915db638356659c9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sal object type certificate.  <a href="group__g__sal__api.html#ga1984b867e1d3d9915db638356659c9bb">More...</a><br /></td></tr>
<tr class="separator:ga1984b867e1d3d9915db638356659c9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51df808f5591cc83cb115c48393b15bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga51df808f5591cc83cb115c48393b15bf">C_SAL_OBJECT__TYPE_SEALED_DATA</a>&#160;&#160;&#160;(3u)</td></tr>
<tr class="memdesc:ga51df808f5591cc83cb115c48393b15bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sal object type sealed data.  <a href="group__g__sal__api.html#ga51df808f5591cc83cb115c48393b15bf">More...</a><br /></td></tr>
<tr class="separator:ga51df808f5591cc83cb115c48393b15bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad4f691b1ad4c49d996a5fbb95056efa9"><td class="memItemLeft" align="right" valign="top"><a id="gad4f691b1ad4c49d996a5fbb95056efa9"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>TKSalObjectType</b></td></tr>
<tr class="separator:gad4f691b1ad4c49d996a5fbb95056efa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__g__sal__api.html#gga06fc87d81c62e9abb8790b6e5713c55ba3ca1ec8266b796c6713f042d114ee1c0">E_K_SAL_OBJECT_TYPE_DATA</a>, 
<br />
&#160;&#160;<a class="el" href="group__g__sal__api.html#gga06fc87d81c62e9abb8790b6e5713c55ba5f1d383d30ea0e7cfea32c5da504bdd8">E_K_SAL_OBJECT_TYPE_RFU_V2</a>, 
<br />
&#160;&#160;<a class="el" href="group__g__sal__api.html#gga06fc87d81c62e9abb8790b6e5713c55ba22ab38b812278768f7775abe4cef39c2">E_K_SAL_OBJECT_TYPE_CERTFICATE</a>, 
<br />
&#160;&#160;<a class="el" href="group__g__sal__api.html#gga06fc87d81c62e9abb8790b6e5713c55ba7b1f31fdb2c02cb76b96b6a698d70984">E_K_SAL_OBJECT_TYPE_SEALED_DATA</a>, 
<br />
&#160;&#160;<a class="el" href="group__g__sal__api.html#gga06fc87d81c62e9abb8790b6e5713c55ba78429ff6e7c812796f926a79b4692f7c">E_K_SAL_OBJECT_TYPE_MAX_NUM</a>
<br />
 }</td></tr>
<tr class="memdesc:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags used in the command fields.  <a href="group__g__sal__api.html#ga06fc87d81c62e9abb8790b6e5713c55b">More...</a><br /></td></tr>
<tr class="separator:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad7b9434208340145e6559c128e57ba14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gad7b9434208340145e6559c128e57ba14">salCryptoHmac</a> (uint32_t xKeyId, const uint8_t *xpInputData, size_t xInputDataLen, uint8_t *xpMac)</td></tr>
<tr class="memdesc:gad7b9434208340145e6559c128e57ba14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function to compute HMAC SHA256. The key is always located inside the secure platform and addressed by an identifier. The computed MAC is always exported to Host.  <a href="group__g__sal__api.html#gad7b9434208340145e6559c128e57ba14">More...</a><br /></td></tr>
<tr class="separator:gad7b9434208340145e6559c128e57ba14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd76519ca9d3be1fd06c8d364b8d0138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gacd76519ca9d3be1fd06c8d364b8d0138">salCryptoHmacVerify</a> (uint32_t xKeyId, const uint8_t *xpInputData, size_t xInputDataLen, const uint8_t *xpMac)</td></tr>
<tr class="memdesc:gacd76519ca9d3be1fd06c8d364b8d0138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function to compute HMAC SHA256 and compare with the provided mac reference. The key is always located inside the secure platform and addressed by an identifier.  <a href="group__g__sal__api.html#gacd76519ca9d3be1fd06c8d364b8d0138">More...</a><br /></td></tr>
<tr class="separator:gacd76519ca9d3be1fd06c8d364b8d0138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dbb57319c48d6491deb390402fabfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gac7dbb57319c48d6491deb390402fabfc">salCryptoAesEnc</a> (uint32_t xKeyId, const uint8_t *xpInputData, size_t xInputDataLen, uint8_t *xpOutputData, size_t *xpOutputDataLen)</td></tr>
<tr class="memdesc:gac7dbb57319c48d6491deb390402fabfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function to encrypt data based on AES-128 CBC. The key is always located inside the secure platform and addressed by an identifier.  <a href="group__g__sal__api.html#gac7dbb57319c48d6491deb390402fabfc">More...</a><br /></td></tr>
<tr class="separator:gac7dbb57319c48d6491deb390402fabfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57735f423b4204965082737daa7c995f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga57735f423b4204965082737daa7c995f">salCryptoAesDec</a> (uint32_t xKeyId, const uint8_t *xpInputData, size_t xInputDataLen, uint8_t *xpOutputData, size_t *xpOutputDataLen)</td></tr>
<tr class="memdesc:ga57735f423b4204965082737daa7c995f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function to decrypt data based on AES-128 CBC. The key is always located inside the secure platform and addressed by an identifier.  <a href="group__g__sal__api.html#ga57735f423b4204965082737daa7c995f">More...</a><br /></td></tr>
<tr class="separator:ga57735f423b4204965082737daa7c995f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1327e3f7a16d4cac95a162c4d22b4087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga1327e3f7a16d4cac95a162c4d22b4087">salCryptoGetRandom</a> (uint8_t *xpRandomData, size_t *xpRandomDataLen)</td></tr>
<tr class="memdesc:ga1327e3f7a16d4cac95a162c4d22b4087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get random value.  <a href="group__g__sal__api.html#ga1327e3f7a16d4cac95a162c4d22b4087">More...</a><br /></td></tr>
<tr class="separator:ga1327e3f7a16d4cac95a162c4d22b4087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29aa2382e87f2767c2465e9f5338d14d"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga29aa2382e87f2767c2465e9f5338d14d">salSignHash</a> (uint32_t xKeyId, uint8_t *xpMsgToHash, size_t xMsgToHashLen, uint8_t *xpSignedHashOutBuff, uint32_t xSignedHashOutBuffLen, size_t *xpActualSignedHashOutLen)</td></tr>
<tr class="memdesc:ga29aa2382e87f2767c2465e9f5338d14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function to sign the hash data. The key is always located inside the secure platform and addressed by an identifier.  <a href="group__g__sal__api.html#ga29aa2382e87f2767c2465e9f5338d14d">More...</a><br /></td></tr>
<tr class="separator:ga29aa2382e87f2767c2465e9f5338d14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f62339ddf6562d5f6aba9ab258f8c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga9f62339ddf6562d5f6aba9ab258f8c41">salPrint</a> (char *xpBuffer)</td></tr>
<tr class="memdesc:ga9f62339ddf6562d5f6aba9ab258f8c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">This api will have the data buffer as input and will print on console to provide logs. If required platform specific definition to be updated by the user.  <a href="group__g__sal__api.html#ga9f62339ddf6562d5f6aba9ab258f8c41">More...</a><br /></td></tr>
<tr class="separator:ga9f62339ddf6562d5f6aba9ab258f8c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5288664b6464112f83047da3d855c2e5"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga5288664b6464112f83047da3d855c2e5">salObjectKeyGen</a> (uint32_t xKeyId, const uint8_t *xpKeyAttributes, size_t xKeyAttributesLen, uint8_t *xpPublicKey, size_t *xpPublicKeyLen, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:ga5288664b6464112f83047da3d855c2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a key pair and persists private key in a platform and returns the public key.  <a href="group__g__sal__api.html#ga5288664b6464112f83047da3d855c2e5">More...</a><br /></td></tr>
<tr class="separator:ga5288664b6464112f83047da3d855c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14d666674f04ea096a2e19057d4d7c37"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga14d666674f04ea096a2e19057d4d7c37">salObjectSet</a> (TKSalObjectType xObjectType, uint32_t xObjectId, const uint8_t *xpDataAttributes, size_t xDataAttributesLen, const uint8_t *xpData, size_t xDataLen, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:ga14d666674f04ea096a2e19057d4d7c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a persistent object in the Platform.  <a href="group__g__sal__api.html#ga14d666674f04ea096a2e19057d4d7c37">More...</a><br /></td></tr>
<tr class="separator:ga14d666674f04ea096a2e19057d4d7c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4fcd3a3ecd834b472c10aa5e23fa71d"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gaf4fcd3a3ecd834b472c10aa5e23fa71d">salObjectKeySet</a> (uint32_t xKeyId, const uint8_t *xpDataAttributes, size_t xDataAttributesLen, const uint8_t *xpKey, size_t xKeyLen, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:gaf4fcd3a3ecd834b472c10aa5e23fa71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets a persistent key object in the Platform.  <a href="group__g__sal__api.html#gaf4fcd3a3ecd834b472c10aa5e23fa71d">More...</a><br /></td></tr>
<tr class="separator:gaf4fcd3a3ecd834b472c10aa5e23fa71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c314c36159631342e69a26d7e56bba"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga45c314c36159631342e69a26d7e56bba">salObjectGet</a> (TKSalObjectType xObjectType, uint32_t xObjectId, uint8_t *xpData, size_t *xpDataLen, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:ga45c314c36159631342e69a26d7e56bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the persistent object from the Platform.  <a href="group__g__sal__api.html#ga45c314c36159631342e69a26d7e56bba">More...</a><br /></td></tr>
<tr class="separator:ga45c314c36159631342e69a26d7e56bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf5113b6d2f097646fec842047f1bb6"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gafbf5113b6d2f097646fec842047f1bb6">salObjectDelete</a> (TKSalObjectType xObjectType, uint32_t xObjectId, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:gafbf5113b6d2f097646fec842047f1bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the persistent object from the Platform.  <a href="group__g__sal__api.html#gafbf5113b6d2f097646fec842047f1bb6">More...</a><br /></td></tr>
<tr class="separator:gafbf5113b6d2f097646fec842047f1bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41df16969d0b1654dcf3a3d8ceb1dc9d"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga41df16969d0b1654dcf3a3d8ceb1dc9d">salObjectKeyDelete</a> (uint32_t xKeyId, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:ga41df16969d0b1654dcf3a3d8ceb1dc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the persistent key object from the Platform.  <a href="group__g__sal__api.html#ga41df16969d0b1654dcf3a3d8ceb1dc9d">More...</a><br /></td></tr>
<tr class="separator:ga41df16969d0b1654dcf3a3d8ceb1dc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8dcb8fc522e6f1e674b9aac2de5bc7"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga1d8dcb8fc522e6f1e674b9aac2de5bc7">salObjectSetWithAssociation</a> (uint32_t xObjectType, uint32_t xObjectWithAssociationId, const uint8_t *xpDataAttributes, size_t xDataAttributesLen, const uint8_t *xpData, size_t xDataLen, <a class="el" href="struct_t_k_sal_obj_association_info.html">TKSalObjAssociationInfo</a> *xpAssociationInfo, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:ga1d8dcb8fc522e6f1e674b9aac2de5bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set in the Platform a persistent object which includes association information.  <a href="group__g__sal__api.html#ga1d8dcb8fc522e6f1e674b9aac2de5bc7">More...</a><br /></td></tr>
<tr class="separator:ga1d8dcb8fc522e6f1e674b9aac2de5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71386afe546d8290de6b8f828f5e3855"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga71386afe546d8290de6b8f828f5e3855">salObjectGetWithAssociation</a> (uint32_t xObjectWithAssociationId, const uint8_t *xpData, size_t *xpDataLen, <a class="el" href="struct_t_k_sal_obj_association_info.html">TKSalObjAssociationInfo</a> *xpAssociationInfo, uint8_t *xpPlatformStatus)</td></tr>
<tr class="memdesc:ga71386afe546d8290de6b8f828f5e3855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get from the Platform a persistent object which includes association information.  <a href="group__g__sal__api.html#ga71386afe546d8290de6b8f828f5e3855">More...</a><br /></td></tr>
<tr class="separator:ga71386afe546d8290de6b8f828f5e3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac11ba9fb8fe5c47cb72a43c46d5869cd"><td class="memItemLeft" align="right" valign="top">TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gac11ba9fb8fe5c47cb72a43c46d5869cd">salPlatformProcess</a> (const uint8_t *xpInBlob, size_t xInBlobLen, uint8_t *xpOutBlob, size_t *xpOutBlobLen)</td></tr>
<tr class="memdesc:gac11ba9fb8fe5c47cb72a43c46d5869cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process blob of data which is device platform specific. Can be 3rd Party specific data blob pre-formatted by Server.  <a href="group__g__sal__api.html#gac11ba9fb8fe5c47cb72a43c46d5869cd">More...</a><br /></td></tr>
<tr class="separator:gac11ba9fb8fe5c47cb72a43c46d5869cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484bae392d0868f5a290f79531fc2e9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga484bae392d0868f5a290f79531fc2e9c">salRotKeyPairGeneration</a> (uint8_t *xpPublicKey)</td></tr>
<tr class="memdesc:ga484bae392d0868f5a290f79531fc2e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a key pair based on ECC NIST P256. The public key is always exported to Host. The private key is always written to C_K_KTA__VOLATILE_ID key identifier.  <a href="group__g__sal__api.html#ga484bae392d0868f5a290f79531fc2e9c">More...</a><br /></td></tr>
<tr class="separator:ga484bae392d0868f5a290f79531fc2e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae275cf7b6743c03238d60049122a13d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gae275cf7b6743c03238d60049122a13d8">salRotKeyAgreement</a> (uint32_t xPrivateKeyId, const uint8_t *xpPeerPublicKey, uint32_t xSharedSecretTarget, uint8_t *xpSharedSecret)</td></tr>
<tr class="memdesc:gae275cf7b6743c03238d60049122a13d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a shared secret based ECDH NIST P256. The private key is always located inside the secure platform and addressed by an identifier. The public key is always provided through a Host buffer. The computed shared secret is either exported to Host or kept inside the secure platform in key identifier(coherent with salRotHkdfExtractAndExpand () "secret" input).  <a href="group__g__sal__api.html#gae275cf7b6743c03238d60049122a13d8">More...</a><br /></td></tr>
<tr class="separator:gae275cf7b6743c03238d60049122a13d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb1732cf58e67139edcaa19d633f45fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gadb1732cf58e67139edcaa19d633f45fc">salRotHkdfExtractAndExpand</a> (uint32_t xMode, const uint8_t *xpSecret, const uint8_t *xpSalt, const uint8_t *xpInfo, size_t xInfoLen)</td></tr>
<tr class="memdesc:gadb1732cf58e67139edcaa19d633f45fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a key based on HKDF HMAC-SHA256 (both Extract and Expand phases). The secret is either provided through a Host buffer or located inside the secure platform in key identifier (coherent with <a class="el" href="group__g__sal__api.html#gae275cf7b6743c03238d60049122a13d8" title="Compute a shared secret based ECDH NIST P256. The private key is always located inside the secure pla...">salRotKeyAgreement()</a> "shared secret" output). The derived key is always kept inside the secure platform.  <a href="group__g__sal__api.html#gadb1732cf58e67139edcaa19d633f45fc">More...</a><br /></td></tr>
<tr class="separator:gadb1732cf58e67139edcaa19d633f45fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1067c6bfe0401e5a27daef89f8a5a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gae1067c6bfe0401e5a27daef89f8a5a74">salRotKeyDerivation</a> (uint32_t xKeyId, const uint8_t *xpInputData, size_t xInputDataLen, uint32_t xDerivedKeyId)</td></tr>
<tr class="memdesc:gae1067c6bfe0401e5a27daef89f8a5a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a key based on HMAC SHA256 and truncate the derived key (128 most significant bits). The key is always located inside the secure platform and addressed by an identifier. The derived key is always kept inside secure platform and addressed by an identifier.  <a href="group__g__sal__api.html#gae1067c6bfe0401e5a27daef89f8a5a74">More...</a><br /></td></tr>
<tr class="separator:gae1067c6bfe0401e5a27daef89f8a5a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05db8a617c0b9e526ecd661bbc1700e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#ga05db8a617c0b9e526ecd661bbc1700e1">salRotGetChipUID</a> (uint8_t *xpChipUid, size_t *xpChipUidLen)</td></tr>
<tr class="memdesc:ga05db8a617c0b9e526ecd661bbc1700e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get chip UID. Chip Platform writes chip_uid which can have a chip specific format and length.  <a href="group__g__sal__api.html#ga05db8a617c0b9e526ecd661bbc1700e1">More...</a><br /></td></tr>
<tr class="separator:ga05db8a617c0b9e526ecd661bbc1700e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b2b8b22be1e7a58bf2308f11e0a7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gaa5b2b8b22be1e7a58bf2308f11e0a7ed">salRotGetChipCertificate</a> (uint8_t *xpChipCert, size_t *xpChipCertLen)</td></tr>
<tr class="memdesc:gaa5b2b8b22be1e7a58bf2308f11e0a7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get chip UID. Chip Platform writes chip_uid which can have a chip specific format and length.  <a href="group__g__sal__api.html#gaa5b2b8b22be1e7a58bf2308f11e0a7ed">More...</a><br /></td></tr>
<tr class="separator:gaa5b2b8b22be1e7a58bf2308f11e0a7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac78faa2a8708b7c0fa10b581e269eb5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gac78faa2a8708b7c0fa10b581e269eb5f">salStorageSetAndLockValue</a> (uint32_t xStorageDataId, const uint8_t *xpData, size_t xDataLen)</td></tr>
<tr class="memdesc:gac78faa2a8708b7c0fa10b581e269eb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">To store and lock the data based on ID.  <a href="group__g__sal__api.html#gac78faa2a8708b7c0fa10b581e269eb5f">More...</a><br /></td></tr>
<tr class="separator:gac78faa2a8708b7c0fa10b581e269eb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54d6d46afdacf48cec2a7509dd35342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gaf54d6d46afdacf48cec2a7509dd35342">salStorageSetValue</a> (uint32_t xStorageDataId, const uint8_t *xpData, size_t xDataLen)</td></tr>
<tr class="memdesc:gaf54d6d46afdacf48cec2a7509dd35342"><td class="mdescLeft">&#160;</td><td class="mdescRight">To store the data based on ID.  <a href="group__g__sal__api.html#gaf54d6d46afdacf48cec2a7509dd35342">More...</a><br /></td></tr>
<tr class="separator:gaf54d6d46afdacf48cec2a7509dd35342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40f22d3a3e4c4a4f9f7def881fd4a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__g__sal__api.html#gae40f22d3a3e4c4a4f9f7def881fd4a03">salStorageGetValue</a> (uint32_t xStorageDataId, uint8_t *xpData, size_t *xpDataLen)</td></tr>
<tr class="memdesc:gae40f22d3a3e4c4a4f9f7def881fd4a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">To get the data based on ID.  <a href="group__g__sal__api.html#gae40f22d3a3e4c4a4f9f7def881fd4a03">More...</a><br /></td></tr>
<tr class="separator:gae40f22d3a3e4c4a4f9f7def881fd4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Common sal constants. </p>
<p>Interface for storage operation.</p>
<p>Interface for RoT operation.</p>
<p>Interface for for third party operations.</p>
<p>Interface for object operation.</p>
<p>Interface for log operation.</p>
<p>Interface for crypto operation.</p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga60436668f147031daa96e2c176de7a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60436668f147031daa96e2c176de7a79">&#9670;&nbsp;</a></span>C_K_KTA__CHIP_SK_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__CHIP_SK_ID&#160;&#160;&#160;(0x0001u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crypto Object Ids. </p>
<p>Chip Secret Key Id(Persistent). </p>

</div>
</div>
<a id="gad547f4070fe49f333e1851c3c14c5ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad547f4070fe49f333e1851c3c14c5ffc">&#9670;&nbsp;</a></span>C_K_KTA__L1_FIELD_KEY_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__L1_FIELD_KEY_ID&#160;&#160;&#160;(0x0002u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L1 Filed Key Id(Persistent). </p>

</div>
</div>
<a id="ga99101c814ce43bf17a954d6fa00c282c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99101c814ce43bf17a954d6fa00c282c">&#9670;&nbsp;</a></span>C_K_KTA__VOLATILE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__VOLATILE_ID&#160;&#160;&#160;(0x8000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volatile Id. </p>

</div>
</div>
<a id="ga8454af66db0bf3bf9e2b9e83bb46cb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8454af66db0bf3bf9e2b9e83bb46cb32">&#9670;&nbsp;</a></span>C_K_KTA__VOLATILE_2_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__VOLATILE_2_ID&#160;&#160;&#160;(0x8001u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volatile 2 Id. </p>

</div>
</div>
<a id="ga13d0adcc686dc3c5a9e4f7a5f1e270f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13d0adcc686dc3c5a9e4f7a5f1e270f1">&#9670;&nbsp;</a></span>C_K_KTA__VOLATILE_3_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__VOLATILE_3_ID&#160;&#160;&#160;(0x8002u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volatile 3 Id. </p>

</div>
</div>
<a id="ga1a74cb2e285608eaf622242192082ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a74cb2e285608eaf622242192082ed8">&#9670;&nbsp;</a></span>C_K_KTA__LIFE_CYCLE_STATE_STORAGE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__LIFE_CYCLE_STATE_STORAGE_ID&#160;&#160;&#160;(0x4000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Persistent Storage_Ids. </p>
<p>Life cycle data ID. </p>

</div>
</div>
<a id="gafb553e6d709a49b8eda083e7ed659431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb553e6d709a49b8eda083e7ed659431">&#9670;&nbsp;</a></span>C_K_KTA__ROT_PUBLIC_UID_STORAGE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__ROT_PUBLIC_UID_STORAGE_ID&#160;&#160;&#160;(0x4001u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rot public UID ID. </p>

</div>
</div>
<a id="gabf931f821fe338a445b20ce5170da082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf931f821fe338a445b20ce5170da082">&#9670;&nbsp;</a></span>C_K_KTA__SEALED_DATA_STORAGE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__SEALED_DATA_STORAGE_ID&#160;&#160;&#160;(0x4002u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sealed data ID. </p>

</div>
</div>
<a id="ga4a3190136a0f640265c246a8bc738ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3190136a0f640265c246a8bc738ac9">&#9670;&nbsp;</a></span>C_K_KTA__L1_KEY_MATERIAL_DATA_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__L1_KEY_MATERIAL_DATA_ID&#160;&#160;&#160;(0x4003u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L1 key material data ID. </p>

</div>
</div>
<a id="ga2b2496245ea4b9d9523dab012ac169ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b2496245ea4b9d9523dab012ac169ce">&#9670;&nbsp;</a></span>C_K_KTA__DEVICE_CERTIFICATE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__DEVICE_CERTIFICATE_ID&#160;&#160;&#160;(0x4004u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device certificate ID. </p>

</div>
</div>
<a id="ga9377b77a84ffea3d7fc317944ebde394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9377b77a84ffea3d7fc317944ebde394">&#9670;&nbsp;</a></span>C_K_KTA__SIGNER_CERTIFICATE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__SIGNER_CERTIFICATE_ID&#160;&#160;&#160;(0x4005u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signer certificate ID. </p>

</div>
</div>
<a id="ga7a130e78400cf1c3f6f2ed7309281372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a130e78400cf1c3f6f2ed7309281372">&#9670;&nbsp;</a></span>C_K_KTA__SIGNER_PUB_KEY_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__SIGNER_PUB_KEY_ID&#160;&#160;&#160;(0x4006u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signer public key. </p>

</div>
</div>
<a id="ga9cbcb95dc7498df4d274bbf2eae65cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cbcb95dc7498df4d274bbf2eae65cdf">&#9670;&nbsp;</a></span>C_K_KTA__HKDF_ACT_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__HKDF_ACT_MODE&#160;&#160;&#160;(0x0000u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HKDF Extract Mode. </p>
<p>Activation Mode. </p>

</div>
</div>
<a id="gad3281679cde4780613e81d006c1d0392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3281679cde4780613e81d006c1d0392">&#9670;&nbsp;</a></span>C_K_KTA__HKDF_GEN_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__HKDF_GEN_MODE&#160;&#160;&#160;(0x0001u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic Mode. </p>

</div>
</div>
<a id="gaba95d7c9b0d8ea6447cb91ac85cd4d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba95d7c9b0d8ea6447cb91ac85cd4d25">&#9670;&nbsp;</a></span>C_K_KTA__CHIPSET_UID_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__CHIPSET_UID_MAX_SIZE&#160;&#160;&#160;(32u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of chipset id field, in bytes. </p>

</div>
</div>
<a id="ga08a9ad49d0d8007b1e0d0b7d239e1d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a9ad49d0d8007b1e0d0b7d239e1d8e">&#9670;&nbsp;</a></span>C_K_KTA__CHIP_CERT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__CHIP_CERT_MAX_SIZE&#160;&#160;&#160;<a class="el" href="crypto_config_8h.html#aff00b687c80be7953eb95b41f90625ac">C_K__CHIP_CERT_MAX_SIZE_VENDOR_SPECIFIC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of chipset cert field, in bytes. </p>

</div>
</div>
<a id="ga0c42ef9955fd67e4e6f0bde190a518f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c42ef9955fd67e4e6f0bde190a518f6">&#9670;&nbsp;</a></span>C_K_KTA__RANDOM_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__RANDOM_MAX_SIZE&#160;&#160;&#160;(256u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of random field, in bytes. </p>

</div>
</div>
<a id="ga34e27a13cddbad36162b503656d2393c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e27a13cddbad36162b503656d2393c">&#9670;&nbsp;</a></span>C_K_KTA__SHARED_SECRET_KEY_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__SHARED_SECRET_KEY_MAX_SIZE&#160;&#160;&#160;(32u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of secret key field, in bytes. </p>

</div>
</div>
<a id="gad65fae2d607180c797d8bf2e9abae6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65fae2d607180c797d8bf2e9abae6d7">&#9670;&nbsp;</a></span>C_K_KTA__PUBLIC_KEY_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__PUBLIC_KEY_MAX_SIZE&#160;&#160;&#160;(64u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of Public key field, in bytes. </p>

</div>
</div>
<a id="ga6d59819f7f89db2af376cf6934b82e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d59819f7f89db2af376cf6934b82e99">&#9670;&nbsp;</a></span>C_K_KTA__HMAC_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__HMAC_MAX_SIZE&#160;&#160;&#160;(16u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of Mac key field, in bytes. </p>

</div>
</div>
<a id="gad913c59c4cf8625f858e15b7bd4e21a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad913c59c4cf8625f858e15b7bd4e21a7">&#9670;&nbsp;</a></span>C_K_KTA__HKDF_ACT_SALT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__HKDF_ACT_SALT_MAX_SIZE&#160;&#160;&#160;(64u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of salt for activation mode key field, in bytes. </p>

</div>
</div>
<a id="ga742053958c22ff18609373a8e854077b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga742053958c22ff18609373a8e854077b">&#9670;&nbsp;</a></span>C_K_KTA__HKDF_GEN_SALT_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__HKDF_GEN_SALT_MAX_SIZE&#160;&#160;&#160;(16u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of salt for generic mode key field, in bytes. </p>

</div>
</div>
<a id="gac4f0c70eff92029a980bdaf30ca88fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4f0c70eff92029a980bdaf30ca88fa2">&#9670;&nbsp;</a></span>C_K_KTA__ROT_PUBLIC_UID_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__ROT_PUBLIC_UID_MAX_SIZE&#160;&#160;&#160;(8u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of Rot public uid field, in bytes. </p>

</div>
</div>
<a id="ga5bee391727a7cdab89de2b46865b1c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bee391727a7cdab89de2b46865b1c00">&#9670;&nbsp;</a></span>C_K_KTA__CMD_FIELD_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__CMD_FIELD_MAX_SIZE&#160;&#160;&#160;(1024u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of command field , in bytes. </p>

</div>
</div>
<a id="gafc11d93065143b24a20b58e1dc16aaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc11d93065143b24a20b58e1dc16aaec">&#9670;&nbsp;</a></span>C_K_KTA__SEALED_INFORMATION_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_K_KTA__SEALED_INFORMATION_MAX_SIZE&#160;&#160;&#160;(133u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximal size of sealed information, in bytes. </p>

</div>
</div>
<a id="ga1a8e84430e52400313049a4910d394ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a8e84430e52400313049a4910d394ee">&#9670;&nbsp;</a></span>K_SAL_API</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define K_SAL_API</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>K Sal Api. </p>

</div>
</div>
<a id="ga66e0c167e5ca0fef754a8b26051cb9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66e0c167e5ca0fef754a8b26051cb9ed">&#9670;&nbsp;</a></span>C_SAL_OBJECT__TYPE_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_SAL_OBJECT__TYPE_DATA&#160;&#160;&#160;(0u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sal object type data. </p>

</div>
</div>
<a id="gad74d4d186f6d96c61dcb56a6c9f8ab47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad74d4d186f6d96c61dcb56a6c9f8ab47">&#9670;&nbsp;</a></span>C_SAL_OBJECT__TYPE_KEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_SAL_OBJECT__TYPE_KEY&#160;&#160;&#160;(1u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sal object type key. </p>

</div>
</div>
<a id="ga1984b867e1d3d9915db638356659c9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1984b867e1d3d9915db638356659c9bb">&#9670;&nbsp;</a></span>C_SAL_OBJECT__TYPE_CERTIFICATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_SAL_OBJECT__TYPE_CERTIFICATE&#160;&#160;&#160;(2u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sal object type certificate. </p>

</div>
</div>
<a id="ga51df808f5591cc83cb115c48393b15bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51df808f5591cc83cb115c48393b15bf">&#9670;&nbsp;</a></span>C_SAL_OBJECT__TYPE_SEALED_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define C_SAL_OBJECT__TYPE_SEALED_DATA&#160;&#160;&#160;(3u)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sal object type sealed data. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga06fc87d81c62e9abb8790b6e5713c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06fc87d81c62e9abb8790b6e5713c55b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags used in the command fields. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55ba3ca1ec8266b796c6713f042d114ee1c0"></a>E_K_SAL_OBJECT_TYPE_DATA&#160;</td><td class="fielddoc"><p>Object type data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55ba5f1d383d30ea0e7cfea32c5da504bdd8"></a>E_K_SAL_OBJECT_TYPE_RFU_V2&#160;</td><td class="fielddoc"><p>Object type rfu. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55ba22ab38b812278768f7775abe4cef39c2"></a>E_K_SAL_OBJECT_TYPE_CERTFICATE&#160;</td><td class="fielddoc"><p>Object type cert. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55ba7b1f31fdb2c02cb76b96b6a698d70984"></a>E_K_SAL_OBJECT_TYPE_SEALED_DATA&#160;</td><td class="fielddoc"><p>Object type sealed data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga06fc87d81c62e9abb8790b6e5713c55ba78429ff6e7c812796f926a79b4692f7c"></a>E_K_SAL_OBJECT_TYPE_MAX_NUM&#160;</td><td class="fielddoc"><p>Object type max num. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad7b9434208340145e6559c128e57ba14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b9434208340145e6559c128e57ba14">&#9670;&nbsp;</a></span>salCryptoHmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salCryptoHmac </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpInputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xInputDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpMac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function to compute HMAC SHA256. The key is always located inside the secure platform and addressed by an identifier. The computed MAC is always exported to Host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Key identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpInputData</td><td>Input data pointer to buffer; Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInputDataLen</td><td>Length of xpInputData. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpMac</td><td>Computed MAC: pointer to buffer. Should not be NULL. Length is fixed to 16-Bytes(C_K_KTA__HMAC_MAX_SIZE), truncated to keep the 16 most significant bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Generic function to compute HMAC SHA256. The key is always located inside the secure platform and addressed by an identifier. The computed MAC is always exported to Host. </p>

</div>
</div>
<a id="gacd76519ca9d3be1fd06c8d364b8d0138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd76519ca9d3be1fd06c8d364b8d0138">&#9670;&nbsp;</a></span>salCryptoHmacVerify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salCryptoHmacVerify </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpInputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xInputDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpMac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function to compute HMAC SHA256 and compare with the provided mac reference. The key is always located inside the secure platform and addressed by an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Key identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpInputData</td><td>Input data pointer to buffer; Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInputDataLen</td><td>Length of xpInputData. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpMac</td><td>Length is fixed to 16-Bytes(C_K_KTA__HMAC_MAX_SIZE), truncated to keep the 16 most significant bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Generic function to compute HMAC SHA256 and compare with the provided mac reference. The key is always located inside the secure platform and addressed by an identifier. </p>

</div>
</div>
<a id="gac7dbb57319c48d6491deb390402fabfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7dbb57319c48d6491deb390402fabfc">&#9670;&nbsp;</a></span>salCryptoAesEnc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salCryptoAesEnc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpInputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xInputDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpOutputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpOutputDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function to encrypt data based on AES-128 CBC. The key is always located inside the secure platform and addressed by an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Key identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpInputData</td><td>Plain input data buffer pointer; Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInputDataLen</td><td>Length of xpInputData. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpOutputData</td><td>Encrypted output data buffer pointer. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpOutputDataLen</td><td>[in] Length of xpOutputData buffer. [out] Length of filled output data. Should not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Generic function to encrypt data based on AES-128 CBC. The key is always located inside the secure platform and addressed by an identifier. </p>

</div>
</div>
<a id="ga57735f423b4204965082737daa7c995f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57735f423b4204965082737daa7c995f">&#9670;&nbsp;</a></span>salCryptoAesDec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salCryptoAesDec </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpInputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xInputDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpOutputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpOutputDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function to decrypt data based on AES-128 CBC. The key is always located inside the secure platform and addressed by an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Key identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpInputData</td><td>Encrypted input data buffer; Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInputDataLen</td><td>Length of xpInputData. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpOutputData</td><td>Plain output data buffer. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpOutputDataLen</td><td>[in] Length of xpOutputData buffer. [out] Length of filled output data. Should not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Generic function to decrypt data based on AES-128 CBC. The key is always located inside the secure platform and addressed by an identifier. </p>

</div>
</div>
<a id="ga1327e3f7a16d4cac95a162c4d22b4087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1327e3f7a16d4cac95a162c4d22b4087">&#9670;&nbsp;</a></span>salCryptoGetRandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salCryptoGetRandom </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpRandomData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpRandomDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get random value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xpRandomData</td><td>Address of buffer where the device platform will write the random data. This buffer must have a minimal size of xpRandomDataLen. Should not be NULL. MAX = 256 Bytes(C_K_KTA__RANDOM_MAX_SIZE). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpRandomDataLen</td><td>[in] Length of xpRandomData buffer. [out] Length of filled output data. Should not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Get random value. </p>

</div>
</div>
<a id="ga29aa2382e87f2767c2465e9f5338d14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29aa2382e87f2767c2465e9f5338d14d">&#9670;&nbsp;</a></span>salSignHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salSignHash </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpMsgToHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xMsgToHashLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpSignedHashOutBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xSignedHashOutBuffLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpActualSignedHashOutLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic function to sign the hash data. The key is always located inside the secure platform and addressed by an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Key identifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpMsgToHash</td><td>Hash To Sign buffer; Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xMsgToHashLen</td><td>Length of xpMsgToHash. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpSignedHashOutBuff</td><td>SignHash output data buffer. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSignedHashOutBuffLen</td><td>SignHash output data length. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpActualSignedHashOutLen</td><td>Length of filled xpSignedHashOutBuff data. Should not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_ERROR for other errors. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9f62339ddf6562d5f6aba9ab258f8c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f62339ddf6562d5f6aba9ab258f8c41">&#9670;&nbsp;</a></span>salPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void salPrint </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>xpBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This api will have the data buffer as input and will print on console to provide logs. If required platform specific definition to be updated by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xpBuffer</td><td>Address of buffer containing input data</td></tr>
  </table>
  </dd>
</dl>
<p>This api will have the data buffer as input and will print on console to provide logs. If required platform specific definition to be updated by the user.</p>
<p>This api will have the data buffer as input and will print on console to provide logs. If required platform specific definition to be updated by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xpBuffer</td><td>Address of buffer containing input data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5288664b6464112f83047da3d855c2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5288664b6464112f83047da3d855c2e5">&#9670;&nbsp;</a></span>salObjectKeyGen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectKeyGen </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpKeyAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xKeyAttributesLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPublicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpPublicKeyLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a key pair and persists private key in a platform and returns the public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Persistent object identifier. Size is fixed to 32-bits. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpKeyAttributes</td><td>Address of buffer containing the key attributes. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyAttributesLen</td><td>Length of the buffer containing the key attributes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPublicKey</td><td>Address of buffer containing the public key. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpPublicKeyLen</td><td>Length of public key buffer (in Bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPlatformStatus</td><td>Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Generates a key pair and persists private key in a platform and returns the public key. </p>

</div>
</div>
<a id="ga14d666674f04ea096a2e19057d4d7c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14d666674f04ea096a2e19057d4d7c37">&#9670;&nbsp;</a></span>salObjectSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpDataAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xDataAttributesLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a persistent object in the Platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xObjectType</td><td>Type of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xObjectId</td><td>Persistent object identifier. Size is fixed to 32-bits. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpDataAttributes</td><td>Address of buffer containing the object data_attributes. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDataAttributesLen</td><td>Length of the buffer containing the object data_attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpData</td><td>Address of buffer containing the object input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDataLen</td><td>Length of object input data buffer (in Bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPlatformStatus</td><td>Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Sets a persistent object in the Platform. </p>

</div>
</div>
<a id="gaf4fcd3a3ecd834b472c10aa5e23fa71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4fcd3a3ecd834b472c10aa5e23fa71d">&#9670;&nbsp;</a></span>salObjectKeySet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectKeySet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpDataAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xDataAttributesLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xKeyLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets a persistent key object in the Platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Persistent key object identifier. Size is fixed to 32-bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpDataAttributes</td><td>Address of buffer containing the object key_attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDataAttributesLen</td><td>Length of the buffer containing the object key_attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpKey</td><td>Address of buffer containing the object input key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyLen</td><td>Length of object input key buffer (in Bytes). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpPlatformStatus</td><td>platform_status out Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>This function sets a persistent key object in the Platform. </p>

</div>
</div>
<a id="ga45c314c36159631342e69a26d7e56bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45c314c36159631342e69a26d7e56bba">&#9670;&nbsp;</a></span>salObjectGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectGet </td>
          <td>(</td>
          <td class="paramtype">TKSalObjectType&#160;</td>
          <td class="paramname"><em>xObjectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the persistent object from the Platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xObjectType</td><td>Type of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xObjectId</td><td>Persistent object identifier. Size is fixed to 32-bits. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpData</td><td>Address of buffer where the device platform will return the output data. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpDataLen</td><td>Address of output buffer length (in Bytes). Caller set the maximum output buffer length expected. Then, the function set the actual length of the output buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPlatformStatus</td><td>Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Gets the persistent object from the Platform. </p>

</div>
</div>
<a id="gafbf5113b6d2f097646fec842047f1bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbf5113b6d2f097646fec842047f1bb6">&#9670;&nbsp;</a></span>salObjectDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectDelete </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the persistent object from the Platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xObjectType</td><td>Type of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xObjectId</td><td>Persistent object identifier. Size is fixed to 32-bits. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPlatformStatus</td><td>Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Deletes the persistent object from the Platform. </p>

</div>
</div>
<a id="ga41df16969d0b1654dcf3a3d8ceb1dc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41df16969d0b1654dcf3a3d8ceb1dc9d">&#9670;&nbsp;</a></span>salObjectKeyDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectKeyDelete </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the persistent key object from the Platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Persistent object identifier. Size is fixed to 32-bits. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPlatformStatus</td><td>Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Deletes the persistent key object from the Platform. </p>

</div>
</div>
<a id="ga1d8dcb8fc522e6f1e674b9aac2de5bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8dcb8fc522e6f1e674b9aac2de5bc7">&#9670;&nbsp;</a></span>salObjectSetWithAssociation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectSetWithAssociation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectWithAssId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpDataAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xDataAttributesLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_k_sal_obj_association_info.html">TKSalObjAssociationInfo</a> *&#160;</td>
          <td class="paramname"><em>xpAssociationInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set in the Platform a persistent object which includes association information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xObjectType</td><td>Type of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xobjectWithAssociationId</td><td>Persistent object identifier. Size is fixed to 32-bits. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpDataAttributes</td><td>Address of buffer containing the object data_attributes. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDataAttributesLen</td><td>Length of the buffer containing the object data_attributes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpData</td><td>Address of buffer containing the object input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDataLen</td><td>Length of object input data buffer (in Bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpAssociationInfo</td><td>Information associated to the Object which are used by internally by keySTREAM Trusted Agent to manage the associated objects and partly by the Application to use the associated objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPlatformStatus</td><td>Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Set in the Platform a persistent object which includes association information. </p>

</div>
</div>
<a id="ga71386afe546d8290de6b8f828f5e3855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71386afe546d8290de6b8f828f5e3855">&#9670;&nbsp;</a></span>salObjectGetWithAssociation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salObjectGetWithAssociation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xObjectWithAssociationId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_k_sal_obj_association_info.html">TKSalObjAssociationInfo</a> *&#160;</td>
          <td class="paramname"><em>xpAssociationInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPlatformStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get from the Platform a persistent object which includes association information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xobjectWithAssociationId</td><td>Persistent object identifier. Size is fixed to 32-bits. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpData</td><td>Address of buffer where the device platform will return the output data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpDataLen</td><td>Address of output buffer length (in Bytes). Caller set the maximum output buffer length expected. Then, the function set the actual length of the output buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpAssociationInfo</td><td>Information associated to the Object which are used by internally by KTA to manage the associated objects. and partly by the Application to use the associated objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPlatformStatus</td><td>Status with Platform format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Get from the Platform a persistent object which includes association information. </p>

</div>
</div>
<a id="gac11ba9fb8fe5c47cb72a43c46d5869cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac11ba9fb8fe5c47cb72a43c46d5869cd">&#9670;&nbsp;</a></span>salPlatformProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TKStatus salPlatformProcess </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpInBlob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xInBlobLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpOutBlob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpOutBlobLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process blob of data which is device platform specific. Can be 3rd Party specific data blob pre-formatted by Server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xpInBlob</td><td>Should not be NULL. Address of buffer containing the input data blob.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInBlobLen</td><td>Length of the buffer containing the input data blob.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpOutBlob</td><td>Should not be NULL. Address of buffer where the device platform will return the output data blob. This parameter is set by caller.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpOutBlobLen</td><td>Address of output buffer length (in Bytes). Should not be NULL. [in] Caller set the maximum output buffer length expected. [out] the function set the actual length of the output buffer; MAX size = 2-Bytes (set at compile-time).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga484bae392d0868f5a290f79531fc2e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484bae392d0868f5a290f79531fc2e9c">&#9670;&nbsp;</a></span>salRotKeyPairGeneration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salRotKeyPairGeneration </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpPublicKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a key pair based on ECC NIST P256. The public key is always exported to Host. The private key is always written to C_K_KTA__VOLATILE_ID key identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xpPublicKey</td><td>Generated public key: pointer to buffer (always exported in clear). Should not be NULL. Length is fixed to 64-Bytes(C_K_KTA__PUBLIC_KEY_MAX_SIZE);</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Generates a key pair based on ECC NIST P256. The public key is always exported to Host. The private key is always written to C_K_KTA__VOLATILE_ID key identifier. </p>

</div>
</div>
<a id="gae275cf7b6743c03238d60049122a13d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae275cf7b6743c03238d60049122a13d8">&#9670;&nbsp;</a></span>salRotKeyAgreement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salRotKeyAgreement </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xPrivateKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpPeerPublicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xSharedSecretTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpSharedSecret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a shared secret based ECDH NIST P256. The private key is always located inside the secure platform and addressed by an identifier. The public key is always provided through a Host buffer. The computed shared secret is either exported to Host or kept inside the secure platform in key identifier(coherent with salRotHkdfExtractAndExpand () "secret" input). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xPrivateKeyId</td><td>Local private key: identifier. The only valid values are C_K_KTA__CHIP_SK_ID and C_K_KTA__VOLATILE_ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpPeerPublicKey</td><td>Peer public key: pointer to buffer. Should not be NULL. Length is fixed to 64-Bytes(ECC NIST P256 Public Key format with both coordinates x||y)(C_K_KTA__PUBLIC_KEY_MAX_SIZE). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xSharedSecretTarget</td><td>bit 31 = 1: Computed shared secret is exported to Host buffer. bit 31 = 0: Computed shared secret is written to provided key identifier. The only valid value is C_K_KTA__VOLATILE_2_ID (content: 32-Bytes). Key identifiers are encoded on 16-bits, cf. "Object ID Management". </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpSharedSecret</td><td>Computed shared secret: pointer buffer. Only applies if xSharedSecretTarget = 0. Length is fixed to 32-Bytes(C_K_KTA__SHARED_SECRET_KEY_MAX_SIZE).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Compute a shared secret based ECDH NIST P256. The private key is always located inside the secure platform and addressed by an identifier. The public key is always provided through a Host buffer. The computed shared secret is either exported to Host or kept inside the secure platform in key identifier(coherent with salRotHkdfExtractAndExpand () "secret" input). </p>
<p>ECDH Key Agreement is the first phase of a common operation with HKDF Key Derivation initialize operation.</p>

</div>
</div>
<a id="gadb1732cf58e67139edcaa19d633f45fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb1732cf58e67139edcaa19d633f45fc">&#9670;&nbsp;</a></span>salRotHkdfExtractAndExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salRotHkdfExtractAndExpand </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpSecret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpSalt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xInfoLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derive a key based on HKDF HMAC-SHA256 (both Extract and Expand phases). The secret is either provided through a Host buffer or located inside the secure platform in key identifier (coherent with <a class="el" href="group__g__sal__api.html#gae275cf7b6743c03238d60049122a13d8" title="Compute a shared secret based ECDH NIST P256. The private key is always located inside the secure pla...">salRotKeyAgreement()</a> "shared secret" output). The derived key is always kept inside the secure platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xMode</td><td>mode = 0: "Activation" message use case(C_K_KTA__HKDF_ACT_MODE). Secret is located in C_K_KTA__VOLATILE_2_ID key identifier (content: 32-Bytes). Salt length = 64-Bytes(C_K_KTA__HKDF_ACT_SALT_MAX_SIZE). Derived key is written to C_K_KTA__VOLATILE_2_ID. mode = 1: "Generic" message use case(C_K_KTA__HKDF_GEN_MODE). Secret is provided through Host buffer. Length fixed to 64-Bytes. Salt length = 16-Bytes(C_K_KTA__HKDF_GEN_SALT_MAX_SIZE). Derived key is written to C_K_KTA__L1_FIELD_KEY_ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpSecret</td><td>Secret for HKDF-extraction phase: pointer to buffer. Only applies if mode=1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpSalt</td><td>Salt for HKDF-extraction phase: pointer to buffer; Should not be NULL. Length is fixed to 64/16 Bytes based on mode. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpInfo</td><td>Info for HKDF-expansion phase: pointer to buffer; Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInfoLen</td><td>Length of xpInfo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Derive a key based on HKDF HMAC-SHA256 (both Extract and Expand phases). The secret is either provided through a Host buffer or located inside the secure platform in key identifier (coherent with <a class="el" href="group__g__sal__api.html#gae275cf7b6743c03238d60049122a13d8" title="Compute a shared secret based ECDH NIST P256. The private key is always located inside the secure pla...">salRotKeyAgreement()</a> "shared secret" output). The derived key is always kept inside the secure platform. </p>

</div>
</div>
<a id="gae1067c6bfe0401e5a27daef89f8a5a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1067c6bfe0401e5a27daef89f8a5a74">&#9670;&nbsp;</a></span>salRotKeyDerivation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salRotKeyDerivation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xKeyId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpInputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xInputDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xDerivedKeyId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derive a key based on HMAC SHA256 and truncate the derived key (128 most significant bits). The key is always located inside the secure platform and addressed by an identifier. The derived key is always kept inside secure platform and addressed by an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xKeyId</td><td>Key identifier The only valid values are C_K_KTA__VOLATILE_2_ID and C_K_KTA__L1_FIELD_KEY_ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpInputData</td><td>Input data pointer to buffer; Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xInputDataLen</td><td>Length of xpInputData. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDerivedKeyId</td><td>Derived key identifier. The only valid values are C_K_KTA__VOLATILE_2_ID and C_K_KTA__VOLATILE_3_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Derive a key based on HMAC SHA256 and truncate the derived key (128 most significant bits). The key is always located inside the secure platform and addressed by an identifier. The derived key is always kept inside secure platform and addressed by an identifier. </p>

</div>
</div>
<a id="ga05db8a617c0b9e526ecd661bbc1700e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05db8a617c0b9e526ecd661bbc1700e1">&#9670;&nbsp;</a></span>salRotGetChipUID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salRotGetChipUID </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpChipUid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpChipUidLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get chip UID. Chip Platform writes chip_uid which can have a chip specific format and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xpChipUid</td><td>Address of buffer where the device platform will write the chip_uid. MAX = 32 Bytes(C_K_KTA__CHIPSET_UID_MAX_SIZE). Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpChipUidLen</td><td>[in] Length of xpChipUid buffer. [out] Length of filled output data. Should not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Get chip UID. Chip Platform writes chip_uid which can have a chip specific format and length. </p>

</div>
</div>
<a id="gaa5b2b8b22be1e7a58bf2308f11e0a7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b2b8b22be1e7a58bf2308f11e0a7ed">&#9670;&nbsp;</a></span>salRotGetChipCertificate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salRotGetChipCertificate </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpChipCert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpChipCertLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get chip UID. Chip Platform writes chip_uid which can have a chip specific format and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">xpChipCert</td><td>Address of buffer where the device platform will write the chip certificate. MAX = 256 Bytes(C_K_KTA__CHIP_CERT_MAX_SIZE). Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpChipCertLen</td><td>[in] Length of xpChipCert buffer. [out] Length of filled output data. Should not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter.</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>Get chip UID. Chip Platform writes chip_uid which can have a chip specific format and length. </p>

</div>
</div>
<a id="gac78faa2a8708b7c0fa10b581e269eb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac78faa2a8708b7c0fa10b581e269eb5f">&#9670;&nbsp;</a></span>salStorageSetAndLockValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salStorageSetAndLockValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xStorageDataId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To store and lock the data based on ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xStorageDataId</td><td>Storage data Identifier. Refer Storage_Ids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpData</td><td>Address of buffer containing the input data. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDataLen</td><td>Length of xpData buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>To store and lock the data based on ID. </p>

</div>
</div>
<a id="gaf54d6d46afdacf48cec2a7509dd35342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf54d6d46afdacf48cec2a7509dd35342">&#9670;&nbsp;</a></span>salStorageSetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salStorageSetValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xStorageDataId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>xpData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To store the data based on ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xStorageDataId</td><td>Storage data Identifier. Refer Storage_Ids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xpData</td><td>Address of buffer containing the input data. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDataLen</td><td>Length of xpData buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>To store the data based on ID. </p>

</div>
</div>
<a id="gae40f22d3a3e4c4a4f9f7def881fd4a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40f22d3a3e4c4a4f9f7def881fd4a03">&#9670;&nbsp;</a></span>salStorageGetValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__g__sal__api.html#ga1a8e84430e52400313049a4910d394ee">K_SAL_API</a> TKStatus salStorageGetValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xStorageDataId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>xpData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>xpDataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To get the data based on ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xStorageDataId</td><td>Storage data Identifier. Refer Storage_Ids. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xpData</td><td>Address of buffer where the device platform will return the output data. Should not be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xpDataLen</td><td>Address of output buffer length (in Bytes). [in] Caller set the maximum output buffer length expected. [out] The function set the actual length of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>E_K_STATUS_OK in case of success.</li>
<li>E_K_STATUS_PARAMETER for wrong input parameter(s).</li>
<li>E_K_STATUS_ERROR for other errors.</li>
</ul>
</dd></dl>
<p>To get the data based on ID. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer"><b></b>
    Copyright &copy; 2023-2024 Nagravision S&agrave;rl.
	- Generated by <a href="https://www.doxygen.org/index.html" target="_new">doxygen</a> 1.8.17</li>
  </ul>
</div>
</body>
</html>